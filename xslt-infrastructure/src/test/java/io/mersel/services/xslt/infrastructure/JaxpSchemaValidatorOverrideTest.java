package io.mersel.services.xslt.infrastructure;

import io.mersel.services.xslt.application.enums.SchemaValidationType;
import io.mersel.services.xslt.application.models.XsdOverride;
import io.mersel.services.xslt.infrastructure.diagnostics.XsltMetrics;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * JaxpSchemaValidator override ve XSD doğrulama birim testleri.
 */
@DisplayName("JaxpSchemaValidatorOverride")
class JaxpSchemaValidatorOverrideTest {

    private static final String MAIN_XSD_PATH = "validator/ubl-tr-package/schema/maindoc/UBL-Invoice-2.1.xsd";

    @TempDir
    Path tempDir;

    private AssetManager assetManager;
    private XsltMetrics metrics;

    @BeforeEach
    void setUp() throws IOException {
        assetManager = mock(AssetManager.class);
        metrics = mock(XsltMetrics.class);

        when(assetManager.getExternalDir()).thenReturn(tempDir);
        when(assetManager.assetExists(anyString())).thenReturn(false);
    }

    private void setupMinimalXsds(Path mainXsd) throws IOException {
        when(assetManager.assetExists(MAIN_XSD_PATH)).thenReturn(true);
        when(assetManager.resolveAssetOnDisk(anyString())).thenReturn(mainXsd);
        Files.createDirectories(tempDir.resolve("auto-generated").resolve("schema-overrides"));
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(tempDir.resolve("auto-generated").resolve("schema-overrides"));
    }

    /**
     * Validator oluşturur ve @PostConstruct init() metodunu tetikler.
     * Spring context kullanmadığımız için reflection ile çağırıyoruz.
     */
    private JaxpSchemaValidator createValidator() {
        JaxpSchemaValidator validator = new JaxpSchemaValidator(assetManager, metrics);
        try {
            // @Value alanlarını set et
            var maxSizeField = JaxpSchemaValidator.class.getDeclaredField("xsdOverrideCacheMaxSize");
            maxSizeField.setAccessible(true);
            maxSizeField.setInt(validator, 50);

            var ttlField = JaxpSchemaValidator.class.getDeclaredField("xsdOverrideCacheTtlHours");
            ttlField.setAccessible(true);
            ttlField.setInt(validator, 1);

            // @PostConstruct init() çağır
            Method initMethod = JaxpSchemaValidator.class.getDeclaredMethod("init");
            initMethod.setAccessible(true);
            initMethod.invoke(validator);
        } catch (Exception e) {
            throw new RuntimeException("Validator init failed", e);
        }
        return validator;
    }

    @Test
    @DisplayName("minOccurs_0_override — minOccurs=1 olan XSD override ile 0 yapılınca eksik element geçmeli")
    void minOccurs_0_override() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="opt" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="opt" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("opt", "0", null));
        byte[] xmlWithoutOpt = "<root/>".getBytes(StandardCharsets.UTF_8);
        List<String> errors = validator.validate(xmlWithoutOpt, SchemaValidationType.INVOICE, overrides);
        assertThat(errors).isEmpty();
    }

    @Test
    @DisplayName("maxOccurs_unbounded_override — maxOccurs=1 override ile unbounded, 2 eleman geçmeli")
    void maxOccurs_unbounded_override() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="item" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(tempDir.resolve("auto-generated").resolve("schema-overrides"));

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("item", null, "unbounded"));
        byte[] xmlWithTwo = "<root><item>a</item><item>b</item></root>".getBytes(StandardCharsets.UTF_8);
        List<String> errors = validator.validate(xmlWithTwo, SchemaValidationType.INVOICE, overrides);
        assertThat(errors).isEmpty();
    }

    @Test
    @DisplayName("override_olmadan_normal_validation — Override yoksa orijinal XSD davranışı korunmalı")
    void override_olmadan_normal_validation() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="req" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="req" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);

        JaxpSchemaValidator validator = createValidator();
        validator.reload();
        byte[] xmlMissingReq = "<root/>".getBytes(StandardCharsets.UTF_8);
        List<String> errors = validator.validate(xmlMissingReq, SchemaValidationType.INVOICE, List.of());
        assertThat(errors).isNotEmpty();
    }

    @Test
    @DisplayName("override_cache_calisiyor — Aynı override iki kez çağrıldığında tekrar derlenmemeli")
    void override_cache_calisiyor() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="opt" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="opt" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);
        Path autoGenDir = tempDir.resolve("auto-generated").resolve("schema-overrides");
        Files.createDirectories(autoGenDir);
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(autoGenDir);

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("opt", "0", null));
        byte[] xml = "<root/>".getBytes(StandardCharsets.UTF_8);

        validator.validate(xml, SchemaValidationType.INVOICE, overrides);
        validator.validate(xml, SchemaValidationType.INVOICE, overrides);

        verify(assetManager, atLeast(1)).writeAutoGenerated(eq("schema-overrides"), anyString(), any(byte[].class));
    }

    @Test
    @DisplayName("override_yazildi_auto_generated — Override sonrası XSD auto-generated dizinine yazılmalı")
    void override_yazildi_auto_generated() throws Exception {
        Path autoGenDir = tempDir.resolve("auto-generated").resolve("schema-overrides");
        Files.createDirectories(autoGenDir);

        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="opt" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="opt" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(autoGenDir);

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("opt", "0", null));
        validator.validate("<root/>".getBytes(StandardCharsets.UTF_8), SchemaValidationType.INVOICE, overrides);

        verify(assetManager).writeAutoGenerated(eq("schema-overrides"), org.mockito.ArgumentMatchers.argThat(
                name -> name != null && name.contains("_override")), any(byte[].class));
    }

    @Test
    @DisplayName("profil_adli_override — profileName ile XSD doğrulama ve dosya adı kontrolü")
    void profil_adli_override() throws Exception {
        Path autoGenDir = tempDir.resolve("auto-generated").resolve("schema-overrides");
        Files.createDirectories(autoGenDir);

        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="opt" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="opt" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(autoGenDir);

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("opt", "0", null));
        List<String> errors = validator.validate(
                "<root/>".getBytes(StandardCharsets.UTF_8),
                SchemaValidationType.INVOICE, overrides, "unsigned");
        assertThat(errors).isEmpty();

        verify(assetManager).writeAutoGenerated(eq("schema-overrides"),
                eq("INVOICE_unsigned_override.xsd"), any(byte[].class));
    }

    @Test
    @DisplayName("eslesmemeyen_override_uyari — Yanlış element adı override ederse hata fırlatmaz ama XSD değişmeden derlenir")
    void eslesmemeyen_override_uyari() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="req" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="req" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);

        JaxpSchemaValidator validator = createValidator();
        // Yanlış element adı — "nonExistent" XSD'de yok
        var overrides = List.of(new XsdOverride("nonExistent", "0", null));
        byte[] xmlMissingReq = "<root/>".getBytes(StandardCharsets.UTF_8);
        // Override eşleşmediği için orijinal XSD kullanılır (req minOccurs=1), hata beklenir
        List<String> errors = validator.validate(xmlMissingReq, SchemaValidationType.INVOICE, overrides);
        assertThat(errors).isNotEmpty();
    }

    @Test
    @DisplayName("invalidateOverrideCache — Cache temizleme sonrası yeniden derleme yapılmalı")
    void invalidateOverrideCache_sonrasi_yeniden_derleme() throws Exception {
        Path mainXsd = tempDir.resolve("test.xsd");
        String xsd = """
                <?xml version="1.0"?>
                <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
                  <xs:element name="root">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element ref="opt" minOccurs="1"/>
                      </xs:sequence>
                    </xs:complexType>
                  </xs:element>
                  <xs:element name="opt" type="xs:string"/>
                </xs:schema>
                """;
        Files.writeString(mainXsd, xsd);
        setupMinimalXsds(mainXsd);
        Path autoGenDir = tempDir.resolve("auto-generated").resolve("schema-overrides");
        Files.createDirectories(autoGenDir);
        when(assetManager.getAutoGeneratedDir("schema-overrides")).thenReturn(autoGenDir);

        JaxpSchemaValidator validator = createValidator();
        var overrides = List.of(new XsdOverride("opt", "0", null));
        byte[] xml = "<root/>".getBytes(StandardCharsets.UTF_8);

        // İlk çağrı — derleme yapılır
        validator.validate(xml, SchemaValidationType.INVOICE, overrides);

        // Cache temizle
        validator.invalidateOverrideCache();

        // İkinci çağrı — cache temizlendiği için yeniden derleme yapılmalı
        validator.validate(xml, SchemaValidationType.INVOICE, overrides);

        // writeAutoGenerated en az 2 kez çağrılmalı (her derleme için 1 kez)
        verify(assetManager, atLeast(2)).writeAutoGenerated(eq("schema-overrides"), anyString(), any(byte[].class));
    }
}
