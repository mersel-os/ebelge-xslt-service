package io.mersel.services.xslt.infrastructure;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.concurrent.*;

/**
 * External asset dizinini dosya değişiklikleri için izler.
 * <p>
 * {@code xslt.assets.watch-enabled=true} olduğunda aktif olur.
 * Dosya değişikliği algılandığında debounce sonrası {@link AssetRegistry#reload()} tetikler.
 * <p>
 * Debounce sayesinde GİB paketindeki 3 dosya aynı anda güncellendiğinde
 * tek bir reload tetiklenir.
 */
@Component
@ConditionalOnProperty(name = "xslt.assets.watch-enabled", havingValue = "true")
public class AssetFileWatcher {

    private static final Logger log = LoggerFactory.getLogger(AssetFileWatcher.class);

    /** Reload tarafından üretilen dosyaların dizini — izleme dışı bırakılır (sonsuz döngü önleme). */
    private static final String IGNORED_DIR = "auto-generated";

    private final AssetRegistry assetRegistry;
    private final long debounceMs;
    private final String externalPath;

    private WatchService watchService;
    private ExecutorService watchExecutor;
    private ScheduledExecutorService debounceExecutor;
    private ScheduledFuture<?> pendingReload;

    public AssetFileWatcher(
            AssetRegistry assetRegistry,
            @Value("${xslt.watcher.debounce-ms:500}") long debounceMs,
            @Value("${xslt.assets.external-path:}") String externalPath) {
        this.assetRegistry = assetRegistry;
        this.debounceMs = debounceMs;
        this.externalPath = externalPath;
    }

    @PostConstruct
    void init() {
        if (externalPath == null || externalPath.isBlank()) {
            log.info("AssetFileWatcher: external-path yapılandırılmamış, dosya izleme atlanıyor");
            return;
        }

        Path watchDir = Path.of(externalPath);
        if (!Files.isDirectory(watchDir)) {
            log.warn("AssetFileWatcher: dizin bulunamadı: {} — dosya izleme atlanıyor", watchDir);
            return;
        }

        try {
            watchService = FileSystems.getDefault().newWatchService();
            registerRecursive(watchDir);

            debounceExecutor = Executors.newSingleThreadScheduledExecutor(r -> {
                Thread t = new Thread(r, "asset-watcher-debounce");
                t.setDaemon(true);
                return t;
            });

            watchExecutor = Executors.newSingleThreadExecutor(r -> {
                Thread t = new Thread(r, "asset-file-watcher");
                t.setDaemon(true);
                return t;
            });
            watchExecutor.submit(this::watchLoop);

            log.info("AssetFileWatcher başlatıldı — {} izleniyor (debounce: {} ms)", watchDir, debounceMs);
        } catch (IOException e) {
            log.error("AssetFileWatcher başlatılamadı: {}", e.getMessage(), e);
        }
    }

    @PreDestroy
    void shutdown() {
        log.info("AssetFileWatcher kapatılıyor...");

        if (watchExecutor != null) {
            watchExecutor.shutdownNow();
        }
        if (debounceExecutor != null) {
            debounceExecutor.shutdownNow();
        }
        if (watchService != null) {
            try {
                watchService.close();
            } catch (IOException e) {
                log.warn("WatchService kapatma hatası: {}", e.getMessage());
            }
        }
    }

    /**
     * WatchService event loop.
     */
    private void watchLoop() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                WatchKey key = watchService.take(); // blocks

                boolean hasRelevantChange = false;

                for (WatchEvent<?> event : key.pollEvents()) {
                    if (event.kind() == StandardWatchEventKinds.OVERFLOW) {
                        continue;
                    }

                    Path changed = ((WatchEvent<Path>) event).context();

                    // auto-generated dizinindeki değişiklikleri yok say (sonsuz döngü önleme)
                    Path watchable = (Path) key.watchable();
                    Path fullPath = watchable.resolve(changed);
                    Path rootDir = Path.of(externalPath);
                    Path relativePath = rootDir.relativize(fullPath);

                    if (isUnderAutoGenerated(rootDir, fullPath)) {
                        log.trace("Auto-generated değişiklik yok sayıldı: {} ({})", changed, event.kind().name());
                        continue;
                    }

                    log.debug("Dosya değişikliği algılandı: {} ({})", changed, event.kind().name());
                    hasRelevantChange = true;
                }

                if (hasRelevantChange) {
                    scheduleReload();
                }

                boolean valid = key.reset();
                if (!valid) {
                    log.warn("WatchKey artık geçerli değil, izleme durduruluyor");
                    break;
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (ClosedWatchServiceException e) {
                break;
            }
        }
    }

    /**
     * Debounce ile reload planlar. Her yeni event zamanlayıcıyı sıfırlar.
     */
    private synchronized void scheduleReload() {
        if (pendingReload != null && !pendingReload.isDone()) {
            pendingReload.cancel(false);
        }

        pendingReload = debounceExecutor.schedule(() -> {
            log.info("Dosya değişikliği algılandı — asset reload tetikleniyor");
            try {
                assetRegistry.reload();
            } catch (Exception e) {
                log.error("File watcher reload hatası: {}", e.getMessage(), e);
            }
        }, debounceMs, TimeUnit.MILLISECONDS);
    }

    /**
     * Path'in auto-generated dizini altında olup olmadığını kontrol eder.
     * Test edilebilirlik için package-private.
     */
    static boolean isUnderAutoGenerated(Path rootDir, Path fullPath) {
        Path relativePath = rootDir.relativize(fullPath);
        return relativePath.toString().replace('\\', '/').startsWith(IGNORED_DIR);
    }

    /**
     * Dizin ve tüm alt dizinlerini WatchService'e kaydeder.
     * {@code auto-generated/} dizini kayıt dışı bırakılır.
     */
    private void registerRecursive(Path root) throws IOException {
        Files.walkFileTree(root, new SimpleFileVisitor<>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                // auto-generated dizinini izleme dışı bırak
                if (dir.getFileName() != null && IGNORED_DIR.equals(dir.getFileName().toString())) {
                    log.debug("Auto-generated dizini izleme dışı bırakıldı: {}", dir);
                    return FileVisitResult.SKIP_SUBTREE;
                }

                dir.register(watchService,
                        StandardWatchEventKinds.ENTRY_CREATE,
                        StandardWatchEventKinds.ENTRY_MODIFY,
                        StandardWatchEventKinds.ENTRY_DELETE);
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
